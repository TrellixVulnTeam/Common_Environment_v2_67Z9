# ---------------------------------------------------------------------------
# |  
# |  ConditionalInvocationQueryMixin.py
# |  
# |  David Brownell (db@DavidBrownell.com)
# |  
# |  08/30/2015 05:40:36 PM
# |  
# ---------------------------------------------------------------------------
# |  
# |  Copyright David Brownell 2015.
# |          
# |  Distributed under the Boost Software License, Version 1.0.
# |  (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
# |  
# ---------------------------------------------------------------------------
import inspect
import os
import re
import stat
import sys
import textwrap

import cPickle as pickle

from CommonEnvironment import Package
from CommonEnvironment import RegularExpression

InvocationQueryMixin = Package.ImportInit().InvocationQueryMixin

# ---------------------------------------------------------------------------
_script_fullpath = os.path.abspath(__file__) if "python" in sys.executable.lower() else sys.executable
_script_dir, _script_name = os.path.split(_script_fullpath)
# ---------------------------------------------------------------------------

# <No __init__> pylint: disable = W0232
# <Too few public methods> pylint: disable = R0903
class ConditionalInvocationQueryMixin(InvocationQueryMixin):

    _FILENAME                               = "Compiler.CIQM.data"
    _TEMPLATE                               = textwrap.dedent(
        """\
        - Generated by ConditionInvocationQueryMixin to track context changes between
        - compilation invocations.
        -
        - ***** Please do not modify this file *****
        {data}
        """)

    # ---------------------------------------------------------------------------
    # |
    # |  Compiler Methods
    # |
    # ---------------------------------------------------------------------------
    @classmethod
    def _GetOptionalMetadata(cls):
        return [ ( "force", False ),
                 ( "output_data_filename_prefix", '' ),
               ] + super(ConditionalInvocationQueryMixin, cls)._GetOptionalMetadata()

    # ---------------------------------------------------------------------------
    @classmethod
    def _GetRequiredContextNames(cls):
        return [ "output_dir",
               ] + super(ConditionalInvocationQueryMixin, cls)._GetRequiredContextNames()

    # ---------------------------------------------------------------------------
    @classmethod
    def _PostprocessContextItem(cls, context):
        context.output_dir = os.path.realpath(context.output_dir)

        if not os.path.isdir(context.output_dir):
            os.makedirs(context.output_dir)

        return super(ConditionalInvocationQueryMixin, cls)._PostprocessContextItem(context)

    # ---------------------------------------------------------------------------
    # |
    # |  InvocationQueryMixin
    # |
    # ---------------------------------------------------------------------------
    
    # ---------------------------------------------------------------------------
    @classmethod
    def _GetInvokeReason(cls, context, verbose_stream):
        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def HaveGeneratorFilesBeenModified(prev_context, prev_modified_time):
            # ---------------------------------------------------------------------------
            def Check(this_cls):
                try:
                    for class_ in inspect.getmro(this_cls):
                        try:
                            filename = inspect.getfile(class_)
                            
                            # The file may not exist if we are working with a bundled distribution
                            if not os.path.isfile(filename):
                                continue
                            
                            if cls._GetModifiedTime(filename) > prev_modified_time:
                                return filename

                        except TypeError:
                            # Will be thrown when attempting to get the file associated
                            # with a builtin.
                            pass
                except:
                    sys.stderr.write("ERROR attempting to get the bases for ", this_cls)
                    raise

            # ---------------------------------------------------------------------------
            
            result = Check(cls)
            if result != None:
                return result

            # Check external plugin files
            for item in cls._GetAdditionalGeneratorItems(context):
                if isinstance(item, str):
                    if cls._GetModifiedTime(item) > prev_modified_time:
                        return item
                else:
                    result = Check(item)
                    if result != None:
                        return result

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def HaveGeneratorItemsBeenAdded(prev_context, prev_modified_time):
            for output_item in cls._GetOutputFilenames(context):
                if output_item not in prev_content.output_items:
                    return output_item

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def HaveGeneratedItesmBeedRemoved(prev_context, prev_modified_time):
            for output_item in prev_content.output_items:
                if output_item not in cls._GetOutputFilenames(context):
                    return output_item

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def AreGeneratedItemsMissing(prev_context, prev_modified_time):
            for item in cls._GetOutputFilenames(context):
                if not os.path.exists(item):
                    return item

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def HaveInputsBeenModified(prev_context, prev_modified_time):
            # If the compiler is based on directories, see if there is anything in the directory that
            # has changed.
            if cls.Type == cls.TypeValue.File:
                input_filenames = cls._GetInputItems(context)
            
            elif cls.Type == cls.TypeValue.Directory:
                input_filenames = []

                for input_dir in cls._GetInputItems(context):
                    for item in os.listdir(input_dir):
                        fullpath = os.path.join(input_dir, item)
                        if not os.path.isfile(fullpath):
                            continue

                        if fullpath in cls._GetOutputFilenames(context):
                            continue

                        if fullpath in cls._GetPersistedFilename(context):
                            continue

                        input_filenames.append(fullpath)
            
            else:
                assert False, cls.TypeValue

            for input_filename in input_filenames:
                if not os.path.isfile(input_filename) or cls._GetModifiedTime(input_filename) > prev_modified_time:
                    return input_filename

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def HasMetadataChanged(prev_context, prev_modified_time):
            prev_metadata_keys = list(prev_content.metadata.keys())

            for k, v in context.__dict__.iteritems():
                if k[0] == '_':
                    continue

                if k not in prev_metadata_keys:
                    return "'{}' is new".format(k)

                if v != prev_content.metadata[k]:
                    return "'{}' has been modified".format(k)

                prev_metadata_keys.remove(k)

            if prev_metadata_keys:
                return "{} are extraneous".format(", ".join([ "'{}'".format(k) for k in prev_metadata_keys ]))

        # ---------------------------------------------------------------------------
        def HasCustomMetadataChanged(prev_context, prev_modified_time):
            return cls._CustomContextComparison(context, prev_content)

        # ---------------------------------------------------------------------------
        # <Unused argument> pylint: disable = W0613
        def ShouldGenerate(prev_context, prev_modified_time):
            result = getattr(cls, "ShouldGenerate", False)
            if result:
                return result

        # ---------------------------------------------------------------------------

        prev_context = {}
        prev_modified_time = 0

        filename = cls._GetPersistedFilename(context)
        if os.path.isfile(filename):
            match = RegularExpression.TemplateStringToRegex(cls._TEMPLATE).match(open(filename).read(), re.MULTILINE | re.DOTALL)
            if match:
                try:
                    prev_content = pickle.loads(match.group("data"))
                    prev_modified_time = cls._GetModifiedTime(filename)
                except:
                    pass

            if not prev_content:
                verbose_stream.write("WARNING: Context information associated with the previous compilation was corrupt; continuing as if not context is available.\n")

        # We don't want force to be persisted
        force = context.force
        del context.force

        # Check the fundamental reasons
        for invoke_reason, desc, functor in [ ( cls.InvokeReason.force, "force was specified", lambda: force ),
                                              ( cls.InvokeReason.prev_context_missing, "previous context is missing", lambda: not prev_context ),
                                            ]:
            if functor():
                verbose_stream.write("\nInvoking because {}.\n\n".format(desc))
                return invoke_reason

        # Check calculated reasons
        for invoke_reason, desc_template, functor in [ ( cls.InvokeReason.newer_generator, "generator files have been modified ({result})", HaveGeneratorFilesBeenModified ),
                                                       ( cls.InvokeReason.added_output, "items to generate have been added ({result})", HaveGeneratorItemsBeenAdded ),
                                                       ( cls.InvokeReason.removed_output, "items to generate have been removed ({result})", HaveGeneratedItesmBeedRemoved ),
                                                       ( cls.InvokeReason.missing_output, "items to generate are missing ({result})", AreGeneratedItemsMissing ),
                                                       ( cls.InvokeReason.newer_input, "input has been modified ({result})", HaveInputsBeenModified ),
                                                       ( cls.InvokeReason.different_metadata, "metadata has changed ({result})", HasMetadataChanged ),
                                                       ( cls.InvokeReason.different_metadata, "metadata has changed ({result})", HasCustomMetadataChanged ),
                                                       ( cls.InvokeReason.opt_in, "the generator opted-in to generation", ShouldGenerate ),
                                                     ]:
            result = functor(prev_context, prev_modified_time)
            if result != None:
                verbose_stream.write("\nInvoking because {}.\n\n".format(desc_template.format(result=result)))
                return invoke_reason

    # ---------------------------------------------------------------------------
    @classmethod
    def _PersistContext(cls, context):
        if not os.path.isdir(context.output_dir):
            os.makedirs(context.output_dir)

        filename = cls._GetPersistedFilename(context)

        with open(filename, 'w') as f:
            f.write(cls._TEMPLATE.format(data=pickle.dumps(PersistedContext(cls, context))))

    # ---------------------------------------------------------------------------
    # |
    # |  Private Methods
    # |
    # ---------------------------------------------------------------------------
    @classmethod
    def _GetPersistedFilename(cls, context):
        return os.path.join(context.output_dir, "{}{}".format(context.output_data_filename_prefix, cls._FILENAME))

    # ---------------------------------------------------------------------------
    @staticmethod
    def _GetModifiedTime(filename):
        # When it comes to Python files, we don't care when the file was compiled but
        # rather when the corresponding source file was modified. If passed a compile 
        # file, look at the associated .py file instead.
        if os.path.splitext(filename)[1].lower() in [ ".pyc", ".pyo", ]:
            filename = filename[:-1]
            assert os.path.isfile(filename), filename

        return os.stat(filename)[stat.ST_MTIME]

# ---------------------------------------------------------------------------
class PersistedContext(object):

    # ---------------------------------------------------------------------------
    def __init__( self,
                  compiler,
                  context,
                ):
        self.metadata = {}

        for k, v in context.__dict__.iteritems():
            if k[0] == '_':
                continue

            self.metadata[k] = v

        self.input_items = compiler._GetInputItems(context)
        self.output_items = compiler._GetOutputFilenames(context)
